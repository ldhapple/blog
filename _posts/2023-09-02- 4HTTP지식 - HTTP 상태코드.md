---
title: HTTP 웹 지식 - HTTP 상태 코드
author: leedohyun
date: 2023-09-02 18:13:00 -0500
categories: [Web, HTTP 웹 기본지식]
tags: [java, Spring, SpringBoot]
---

## HTTP 상태코드

클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능.

- 1xx : 요청이 수신되어 처리 중 (거의 사용하지 않음)
- 2xx(Successful) : 요청 정상 처리
- 3xx(Redirection) : 요청을 완료하려면 추가적인 행동이 필요
- 4xx(Client Error) : 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행 불가.
- 5xx(Server Error) : 서버 오류, 서버가 정상 요청을 처리하지 못함.

> 만약 모르는 상태 코드가 나타난다면?

미래에 새로운 상태 코드가 추가되는 등의 상황이 있어서 모르는 상태코드가 나오면 위의 내용을 바탕으로 상위 상태코드로 해석해 처리.

599면 아 서버에서 문제가 발생했구나 하고 해결 시도하는 식.

### 1xx (Informational)

처리 중의 의미를 가지며 거의 사용하지 않으므로 설명 생략.

### 2xx(Successful)

성공. 클라이언트의 요청을 성공적으로 처리.

- 200 OK
- 201 Created
- 202 Accepted
- 204 No Content

![](https://blog.kakaocdn.net/dn/czleO0/btssTmvpLxh/KfuCesIFXngygT5gV7vvBK/img.png)

클라이언트의 요청을 성공적으로 처리한 후 응답할 때 사용.

![](https://blog.kakaocdn.net/dn/B8ntS/btss9AdYB7z/1KUZjkU0aRKymwF52A32Lk/img.png)

POST를 이용해 json 데이터와 같은 사람을 추가해 달라고 요청한 상황.

이런 경우 성공적으로 리소스를 생성했다면 201 코드를 보내고, 헤더에 Location을 담아 해당 리소스의 위치를 알려주기도 함.

> 202 Accepted

요청이 접수되었으나 처리가 완료되지 않았음. 의 의미이다.

- 배치 처리 같은 곳에서 사용한다.
- ex) 요청 접수 후 1시간 뒤에 배치 프로세스가 요청을 처리한다.
- 잘 사용하지 않는다.

> 204 No Content

서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없다.

- 웹 문서 편집기에서 save 버튼을 누르는 상황을 가정하자.
- save 버튼의 결과로 저장은 성공이고 같은 화면은 유지하게 된다. 하지만 결과로 저장의 성공만 알면 되고 위의 201, 202 예시처럼 해당 데이터를 알 필요는 없기 때문에 이럴 경우 사용한다.
- 결과 내용이 없어도 204 메시지 (2xx) 만으로 성공을 인식할 수 있다.

### 3xx (Redirection)

요청을 완료하기 위해 유저 에이전트(클라이언트 프로그램으로 주로 웹브라우저)의 추가 조치가 필요합니다.

> 리다이렉션?

![](https://blog.kakaocdn.net/dn/edXPeu/btss86EcG2d/WW66eMkHKYldMMPkl9Cg7k/img.png)

- 웹 브라우저는 3xx 응답 결과에 Location 헤더가 있으면 Location 위치로 자동 이동.
- 위의 예시에서는 /event url로 접근했는데 이제 이 경로는 사용하지 않고 변경되었다를 301 Moved Permanently 라고 응답한 것이다.
- Location 헤더를 통해 자동으로 /new-event 로 리다이렉트가 발생하고 클라이언트는 다시 요청하게 되는 것이다.

#### 영구 리다이렉션 (301, 308)

특정 리소스의 URI가 영구적으로 이동.

ex) /members -> /users

- 원래의 URL을 사용X, 검색 엔진 등에서도 변경을 인지한다.
- 301 Moved Permanently -> 리다이렉트 시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있다.
- 308 Permanent Redirect -> 301과 기능은 같다. 리다이렉트시 요청 메서드와 본문을 유지한다.

![](https://blog.kakaocdn.net/dn/buNfva/btssTgB9Vtm/TQq33qnD918amTbivbUM1K/img.png)

나는 등록을 위해 POST 요청을 보냈는데, GET으로 변경되어 지는 것이다. 등록을 위한 새로운 폼을 보여준다거나 하는 식. 같은 동작이라면 새로운 폼에서 다시 데이터를 POST 하게 될 것이다.

![](https://blog.kakaocdn.net/dn/qZ3PD/btssVHerO3L/9ktl7maYIosiJQiGRYPXo1/img.png)

위의 301에서 다시 POST 해야하는 문제를 해결한다. 하지만 실무에서는 보통 저렇게 URL이 변하면 새로운 데이터가 필요한 경우가 많으므로 301을 통해 GET으로 돌리는 것이 맞다. (하지만 301도 많이 사용되진 않는다. 이런 상황이 많이 없다.)

#### 일시 리다이렉션

일시적인 변경

ex) 주문 완료 후 주문 내역 화면으로 이동

- 리소스의 URI가 일시적으로 변경
- 따라서 영구 리다이렉션처럼 검색 엔진 등에서 URL을 변경하면 안된다.
- 302 Found -> 리다이렉트시 (대부분) 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있다.
- 307 Temporary Redirect -> 302와 기능은 같다. 리다이렉트시 요청 메서드와 본문을 유지한다. (반드시 요청 메서드를 변경하면 안된다.)
- 303 See Other -> 302와 기능은 같다. 리다이렉트시 요청 메서드가 (반드시) GET으로 변경된다. (실무에서는 302를 많이 사용한다.)

> PRG : POST/Redirction/GET

- POST로 주문 후 웹 브라우저를 새로고침하면?
- 새로고침은 재요청이기 때문에 중복 주문이 될 수 있다. 이럴 때 일시 리다이렉션을 사용한다.
- PRG를 사용한다.

아래 PRG를 사용하기 전의 경우를 보자.

![](https://blog.kakaocdn.net/dn/dB6Vrm/btss3EnTLV4/vjzRzK0NM3mm1te1Xqrxx0/img.png)

/orders를 통해 주문요청을 POST한다. 주문이 성공하고 200 OK를 보낸다. 이 때 결과화면에서 새로고침을 하게 되면 POST 요청을 다시 하게 되는 것이고 주문이 다시 된다. (물론 원칙적으로는 주문ID같은 것으로 클라이언트의 실수를 막도록 설계해야 한다.)

주문ID와 같은 방지책에 더해 PRG를 통해 POST로 주문 후 주문 결과 화면을 GET 메서드로 리다이렉트해 추가적으로 실수를 방지한다.

![](https://blog.kakaocdn.net/dn/ygdl4/btss84TXDHv/7AfwioAaukvxcFI0DVNWAk/img.png)

첫 POST 의 결과가 200이 아닌 302로 바뀌었다. /order-result 라는 위치로 리다이렉션하도록 하고 그 URL은 GET 요청을 하도록 되어있는 것이다. 이렇게 하면 새로고침을 해도 주문을 다시 POST하는 것이 아닌 주문 데이터를 조회하는 GET이기 때문에 결과 화면만 조회되고 중복 주문이 해결된다.

> 302, 307, 303.. 그래서 무엇을 써야하나?

- 처음 302의 의도는 HTTP 메서드를 유지하는 것에 있었다.
- 하지만 웹 브라우저들이 대부분 GET으로 바꿔버리게 된다.
- 그래서 모호한 302를 대신하는 명확한 307, 303이 등장하게 된 것이다.

메서드가 변하면 안되는 307, GET으로 반드시 변경되는 303이 권장되지만 현실적으로 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용하고 있어 자동 리다이렉션시 GET으로 변해도 된다면 302를 사용해도 큰 문제가 없다. 

#### 기타 리다이렉션

- 300 Multiple Choices : 사용하지 않는다.
- 304 Not Modified : 캐시를 목적으로 사용한다.
	- 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용한다. (캐시로 리다이렉트 한다.)
	- 304 응답은 응답에 메시지 바디를 포함하면 안된다. (로컬 캐시를 사용해야 하므로)

### 4xx (Client Error)

클라이언트의 요청에 잘못된 문법 등으로 서버가 요청을 수행할 수 없다는 의미.

★ 클라이언트가 이미 잘못된 요청, 데이터를 보내고 있기 때문에 똑같은 재시도가 실패한다. 

이것이 4xx와 5xx의 가장 큰 차이이다. 예를 들어 서버DB에 문제가 발생하면 5xx오류가 발생할텐데 서버 DB가 복구되면 클라이언트의 똑같은 재시도가 5xx에서는 성공할 가능성이 있는 것이다.

- 400 Bad Request : 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없다.
	- 요청 구문, 메시지 등등의 오류
	- 클라이언트는 요청 내용을 다시 검토하고 보내야 한다.
-  401 Unauthorized : 클라이언트가 해당 리소스에 대한 인증이 필요하다.
	- 인증이 되지 않은 경우이다. (로그인이 되지 않았다.)
	- 401 오류 발생 시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명한다.
- 403 Forbidden : 서버가 요청을 이해했지만 승인을 거부한다.
	- 주로 인증 자격 증명은 있지만 접근 권한이 불충분한 경우에 쓰인다.
	- 로그인은 했지만 사용자 등급이 도달하지 못한 경우를 예로 들 수 있다.
- 404 Not Found : 요청 리소스를 찾을 수 없다.
	- 요청 리소스가 서버에 없는 것이다.
	- 또는 클라이언트가 권한이 부족한 리소스에 접근하려 할 때 그 리소스를 숨기려는 의도로 404를 사용하기도 한다.

### 5xx (Server Error)

서버의 문제로 오류가 발생한 상태. 서버에 문제가 있기 때문에 재시도하면 성공할 수도 있다.

- 500 Internal Server Error : 서버 문제로 오류가 발생한 것.
	- 서버 내부 문제로 오류 발생한 경우.
	- 상황이 애매한 경우 500 오류를 사용하게 된다.
- 503 Service Unavailable : 서비스를 이용 불가능한 경우
	- 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없는 상태
	- Retry - After 헤더 필드로 얼마 뒤 복구되는지 보낼 수 있다. 

> 서버는 웬만해서 5xx 오류를 만들면 안된다.

예를 들어 고객의 잔고가 부족하다던지, 나이가 안된다던지 이런 경우 5xx 오류를 통해 처리하면 안된다. 정말 서버에 문제가 생겼을 때만 사용해야 한다.