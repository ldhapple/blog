---
title: 메모리계층, 가상메모리, 페이지 교체 알고리즘
author: leedohyun
date: 2023-09-19 17:13:00 -0500
categories: [CS, 운영체제]
tags: [CS, 운영체제]
---

## 메모리계층 (memory hierarchy)

레지스터, 캐시, 주기억장치, 보조기억장치로 구성되어 있다.

- 레지스터 : CPU 내의 작은 메모리.
	- 속도가 가장 빠르다.
	- 휘발성이 있고 기억 용량이 가장 적다.
- 캐시 : CPU내의 L1, L2 캐시를 지칭한다.
	- 속도가 빠르다.
	- 휘발성이 있고 기억 용량이 적다.
- 주기억장치 : RAM을 가리킨다.
	- 속도 보통
	- 휘발성이 있고 기억 용량은 보통.
-   보조기억장치 : HDD, SDD
	- 속도가 느리다.
	- 비휘발성이며 기억 용량이 크다.

아래로 내려올수록 속도가 느리고 기억용량이 많아진다.

RAM이 주기억장치, SSD/HDD가 보조기억장치임을 기억.

### 계층이 존재하는 이유

위로 올라갈 수록 빠르지만 비싸다는 것을 명심.

- 더 빠른 접근과 처리속도 증가
	- 사용자는 자주쓰는 특정 데이터에 많이 접근하게 되는데 좀 더 작은 캐시 메모리에 해당 데이터를 두어 더 빠르게 해당 데이터에 접근하고 처리도 빠르게 할 수 있다.
- 비용에 효율적
	- 캐시 메모리는 비싸고 램 등 아래로 갈수록 비용은 더 저렴하다.
	- 계층이 있고 캐싱할 수 있기 때문에 비용을 조금 더 효율적으로 쓸 수 있다. 
- 자원의 효율적 사용
	-  메모리 계층 구조는 자주 접근하는 데이터는 빠른 메모리에, 덜 접근하는 데이터는 느린 메모리에 저장해 자원을 효율적으로 사용할 수 있다.
	- 거의 접근하지 않는 데이터에는 비싸고 빠른 메모리를 사용하지 않게 되어 자원을 낭비하지 않을 수 있다.

## 가상메모리

가상 메모리는 OS에서 사용되는 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원(실제 주소)을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이도록 만드는 것을 말한다.

![](https://blog.kakaocdn.net/dn/bE41NZ/btsuWX0tgEj/JnZZAqk3f4uPd6OE58Swgk/img.png)

가상주소가 MMU와 페이지테이블에 의해 실제 주소(실제 메모리 자원)로 변환된다.

- 페이지 : 가상 메모리를 사용하는 최소 크기 단위
- 프레임 : 실제 디스크나 메모리를 사용하는 최소 크기 단위

> 페이지테이블

가상 주소와 실제 주소가 매핑되어있다. 

이 때 속도 향상을 위해 캐싱계층인 TLB를 쓴다.

가상주소에서 바로 페이지 테이블을 가는 것이 아닌 TLB에서 있는지 확인하고 만약 없다면 페이지 테이블로 가서 실제 주소를 가져온다.

### 페이지폴트 & 스와핑

가상메모리는 작은 메모리를 매우 큰 메모리로 보이게끔 하는 것이기 때문에 참조하려는 메모리 영역이 실제에는 없을 수도 있다.

즉 가상메모리에는 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우가 있으며 이 때 **페이지폴트**가 발생한다.

![](https://blog.kakaocdn.net/dn/b9HfS6/btsuWX7cRJk/W6KUQMV2KMA97kkRKTEcLk/img.png)

이 때 메모리의 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 사용하는 것을 **스와핑**이라고 한다.

#### 페이지 폴트의 과정

![](https://blog.kakaocdn.net/dn/cPRw8d/btsuQwI7AWL/qm0vjrmkbYRw5Fh6Brgbhk/img.png)

1. 어떤 명령어가 유효한 가상주소에 접근했으나 해당 페이지가 만약 없다면 트랩이 발생되어 운영체제에 알린다.
2. 운영체제는 실제 디스크로부터 사용하지 않는 프레임을 찾는다.
3. 해당 프레임을 실제 메모리에 가져와 페이지교체알고리즘을 기반으로 특정 페이지와 교체한다.
4. 페이지테이블을 갱신시킨 후 해당 명령어를 다시 시작한다.


### 스레싱

메모리의 페이지 폴트율이 높은 것을 의미한다.

스레싱은 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나 발생하게 된다.

페이지 폴트가 일어나면 CPU 이용률은 낮아지고 CPU 이용률이 낮아지게 되면 운영체제는 CPU의 가용성을 높이기 위해 더 많은 프로세스를 메모리에 올리게 된다. 이러한 악순환이 반복되어 스레싱이 일어나게 된다.

> 스레싱의 해결방법

- 하드웨어 : 메모리를 늘린다 / HDD를 사용중이라면 SSD로 교체한다.
- 소프트웨어 : 작업세트 / PFF

#### 작업세트

프로세스의 과거 사용이력을 기반으로 많이 사용하는 페이지 집합을 만들어 한꺼번에 미리 메모리에 로드하는 것을 말한다.

#### PFF

페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만들고 상한선에 도달한다면 프레임을 늘리고 하한선에 도달한다면 프레임을 줄이는 방법이다.

### 가상 메모리의 필요성

- 주기억장치의 효율적 관리(스와핑)
	- 하드디스크를 주기억장치에 대한 캐시로 설정해 당장 사용하는 영역만 유지하고 쓰지 않는 데이터는 하드디스크로 옮겨 효율적으로 관리할 수 있다.
- 메모리 관리의 단순화
	- 각 프로세스마다 가상메모리의 통일된 주소 공간을 배정할 수 있으므로 메모리 관리가 단순해진다.
- 메모리 용량 및 안정성 보장
	- 한정된 공간의 램이 아닌 거의 무한한 가상메모리 공간을 배정함으로써 프로세스들끼리 메모리 침범이 일어날 여지를 크게 줄이게 된다.

## 페이지 교체 알고리즘

스와핑이 일어날 때 페이지 교체 알고리즘에 의해 페이지가 교체된다.

### 오프라인 알고리즘 (LFD)

가장 좋은 알고리즘이라고 일컫는 알고리즘이며 이는 가장 먼 미래에 참조되는 페이지와 현재의 페이지를 바꾸는 알고리즘이다.

그러나 미래에 사용되는 프로세스를 우리는 알 수 없다. 예를 들면 크롬브라우저를 이용하다가 갑자기 어떤 게임을 한다던지 이런 미래를 예측할 수 없기 때문에 사실은 사용할 수 없는 알고리즘이다.

단, 다른 알고리즘과의 성능 비교에 대한 상한선을 제공한다.

### FIFO

가장 먼저 온 페이지부터 교체하는 방법이다.

### LRU (Least Recently Used)

최근에 사용되지 않은 페이지를 바꾸는 방법이다.

즉 참조가 오래된 페이지를 바꾼다. 이를 위해 각 페이지마다 최근 사용한 횟수를 나타내는 자료구조를 따로 만들어야 할 수도 있다.

![](https://blog.kakaocdn.net/dn/QClyI/btsu2aY1Fxq/Pi3D3sxZAJp43e05ZKJoN1/img.png)

7 0 1 2 0 3 0 4 의 순서로 페이지 요청이 들어온다고 가정한다.

1. 7 0 1 2 를 담고 그 다음 0이 들어왔을 때는 스와핑이 일어나지 않는다.
2. 그 다음 3이 들어왔을 때 참조가 가장 오래된 7과 바꾼다.
3. 이후 0이 들어오고 스와핑은 일어나지 않는다.
4. 그리고 4가 들어왔을 때 가장 오래된 1과 교체한다.

### NUR(Not Used Recently)

LRU에서 발전한 알고리즘이다.

![](https://blog.kakaocdn.net/dn/D0nDT/btsuIAliW6t/XxzWzDvKnxPFvXNF30GpK0/img.png)

0과 1을 가진 비트를 두고 1은 최근에 참조되었고 0은 참조되지 않았음을 의미한다.

만약 한 바퀴를 도는 동안 사용되지 않으면 0이 된다. 시계 방향으로 돌면서 0을 찾고 0을 찾은 순간 해당 페이지를 교체하고 해당 부분을 1로 바꾸어주는 알고리즘이다.

### LFU(Least Frequently Used)

가장 참조 횟수가 적은 페이지를 교체하는 알고리즘이다.