---
title: 코테 심화(dfs, bfs, 동적계획법, 그리디 등등)
author: leedohyun
date: 2023-06-03 23:13:00 -0500
categories: [JAVA, Data-Structure]
tags: [java, algorithm, data-structure]
---

## 동적 프로그래밍

- 재귀 + 메모이제이션

이미 계산한 부분을 따로 저장하여 중복 계산하지 않도록 하는 방법.

** 재귀가 크게 중복되지 않는데 이러한 방법을 사용하면 오히려 비효율적이기 때문에 확인해야 한다.

ex) 피보나치 수열

```
mem[] = -1;

public static int fibonacci(int n)
{
	if(n == 0 || n == 1) return n;
	if(mem[n] != -1) return mem[n];
	
	return mem[n] = fibonacci(n-1) + fibonacci(n-2);
}
```

## 그래프

그래프를 나타내려면 정점을 나타낼 수 있어야 하고, 정점들이 어떻게 연결되어 있는지 나타내는 간선 정보를 표현할 수 있어야 한다.

1. 인접행렬
2. 인접리스트

- 인접행렬은 2차원배열을 통해 그래프를 나타낸 것으로 간선 정보에 따라 원소만 넣으면 되기때문에 구현이 쉽다. 하지만 정점 개수가 너무 많으면 2차원배열 할당자체가 힘들수있고, 한 정점과 연결된 정점을 찾으려면 2차원 배열에서 하나의 열을 모두 순회해야한다는 단점이 있다.

- 인접리스트는 정점이 연결된 정점들을 리스트로 표현하는 방식이다. 이 방식은 원소가 리스트인 1차원 배열로 그래프를 표현가능하다. 메모리가 훨씬 적다는 장점이 있고, 특정 정점과 간선으로 연결된 정점들만 쉽게 순회가능하다. 하지만 임의의 두 정점 사이에 간선이 있는지 알려면 한 정점과 연결된 모든 정점을 순회하며 찾아보아야 하는 단점이 있다.

```
int[][] result = {{4,3}, {4,2}, {3,2}, {1,2}, {2,5}};
//{4,3} 이라면 4가 3보다 우위에 있다는 뜻이라고 가정.

boolean[][] graph = new boolean[result.length][result.length];
//우위에 있다는 것을 true로 표현하는 그래프

for(int[] edge : result)
{
	int u = edge[0] - 1; // -1은 result 값이 1~5이기 때문.
	int v = edge[1] - 1;

	graph[u][v] = true;
}

//이렇게 했을 때 그래프에는 행을 기준으로 열의 index에게 
우위에 있을 때 true 값을 담게 된다.
```

## 이진트리

- 이진트리의 순회

1. 전위순회
2. 중위순회
3. 후위순회

전위순회는

노드 -> 왼쪽 서브트리 -> 오른쪽 서브트리 순으로 순회를 진행한다.

중위 순회는

왼쪽 서브트리 -> 노드 -> 오른쪽 서브트리

후위 순회는 양쪽 서브트리를 모두 방문한 후 노드를 방문하는 순회 방식

```
//전위순회
void pre(Node node){
	if(node == null) return;
	
	System.out.println(node.data);

	pre(node.left);
	pre(node.right);
}

//중위 순회
void in(Node node){
	if(node == null) return;

	in(node.left);

	System.out.println(node.data);

	in(node.right);
}

//후위 순회
void post(Node node){
	if(node == null) return;
	
	post(node.left);
	post(node.right);

	System.out.println(node.data);
}
```


## 우선순위 큐

## 투 포인터

## 유니온 파인드

## dfs (임시)

완전탐색. 스택과 재귀로 구현이 가능한데 보통 재귀를 선호한다.

for문을 통해 전체를 탐색한다.

visit[]로 방문했는지 체크하고

select[]로 선택한 원소들을 저장한다. 이후 다음 원소를 선택하기 위해 재귀를 통해 전이.

최종 index에 도달했을 때 규칙을 통해 적합한지 검사한다.

최종 index에 전이되고 적합한지 검사한 후 visit[]와 selec을 초기화하고 첫 for문의 i++이 되면 2로 시작하는 모든 경우의 수를 돈다.

//1,2,3,4,5,6,7,8이 있으면 1로 시작하는 모든 경우의 수를 돌게 된 것

## bfs

## 그리디 알고리즘