---
title: 코테 심화(dfs, bfs, 동적계획법, 그리디 등등)
author: leedohyun
date: 2023-06-03 23:13:00 -0500
categories: [JAVA, Data-Structure]
tags: [java, algorithm, data-structure]
---

## 동적 프로그래밍

- 재귀 + 메모이제이션

이미 계산한 부분을 따로 저장하여 중복 계산하지 않도록 하는 방법.

** 재귀가 크게 중복되지 않는데 이러한 방법을 사용하면 오히려 비효율적이기 때문에 확인해야 한다.

ex) 피보나치 수열

```
mem[] = -1;

public static int fibonacci(int n)
{
	if(n == 0 || n == 1) return n;
	if(mem[n] != -1) return mem[n];
	
	return mem[n] = fibonacci(n-1) + fibonacci(n-2);
}
```

## 그래프

그래프를 나타내려면 정점을 나타낼 수 있어야 하고, 정점들이 어떻게 연결되어 있는지 나타내는 간선 정보를 표현할 수 있어야 한다.

1. 인접행렬
2. 인접리스트

- 인접행렬은 2차원배열을 통해 그래프를 나타낸 것으로 간선 정보에 따라 원소만 넣으면 되기때문에 구현이 쉽다. 하지만 정점 개수가 너무 많으면 2차원배열 할당자체가 힘들수있고, 한 정점과 연결된 정점을 찾으려면 2차원 배열에서 하나의 열을 모두 순회해야한다는 단점이 있다.

- 인접리스트는 정점이 연결된 정점들을 리스트로 표현하는 방식이다. 이 방식은 원소가 리스트인 1차원 배열로 그래프를 표현가능하다. 메모리가 훨씬 적다는 장점이 있고, 특정 정점과 간선으로 연결된 정점들만 쉽게 순회가능하다. 하지만 임의의 두 정점 사이에 간선이 있는지 알려면 한 정점과 연결된 모든 정점을 순회하며 찾아보아야 하는 단점이 있다.

```
int[][] result = [[4,3], [4,2], [3,2], [1,2], [2,5]];
//{4,3} 이라면 4가 3보다 우위에 있다는 뜻이라고 가정.

boolean[][] graph = new boolean[result.length][result.length];
//우위에 있다는 것을 true로 표현하는 그래프

for(int[] edge : result)
{
	int u = edge[0] - 1; // -1은 result 값이 1~5이기 때문.
	int v = edge[1] - 1;

	graph[u][v] = true;
}

//이렇게 했을 때 그래프에는 행을 기준으로 열의 index에게 
우위에 있을 때 true 값을 담게 된다.
```

## 이진트리

- 이진트리의 순회

1. 전위순회
2. 중위순회
3. 후위순회

전위순회는

노드 -> 왼쪽 서브트리 -> 오른쪽 서브트리 순으로 순회를 진행한다.

중위 순회는

왼쪽 서브트리 -> 노드 -> 오른쪽 서브트리

후위 순회는 양쪽 서브트리를 모두 방문한 후 노드를 방문하는 순회 방식

```
//전위순회
void pre(Node node){
	if(node == null) return;
	
	System.out.println(node.data);

	pre(node.left);
	pre(node.right);
}

//중위 순회
void in(Node node){
	if(node == null) return;

	in(node.left);

	System.out.println(node.data);

	in(node.right);
}

//후위 순회
void post(Node node){
	if(node == null) return;
	
	post(node.left);
	post(node.right);

	System.out.println(node.data);
}
```


## 우선순위 큐

우선순위 큐 = 힙 = '최솟값' 또는 '최댓값'을 '빠르게' 찾아내기 위한 '완전이진트리' 형태로 만들어진 자료 구조.

특정 원소 중에서 최대 우선순위를 가지는 값을 효율적으로 구하려고 고안된 자료 구조.

우선순위 큐는 원소의 삽입, 최대 우선 순위 값 뽑기의 두 가지 연산을 지원한다.

```
PriorityQueue<Integer> pq = new PriorityQueue<>();
PriorityQueue<Integer> pq_2 = new PriorityQueue<>((a,b) -> b-a);
PriorityQueue<Point> pq_3 = new PriorityQueue<>((a,b) -> a.x - b.x);
//pq_3 처럼 Point 같은 클래스를 pq에 담는다면 우선순위 조건을 지정해줄 수 있다.

pq.add(4);
pq.add(2);
pq.add(6);

pq.poll(); // 2
pq.poll(); // 4
pq.poll(); // 6
//pq_2 에서처럼 람다식을 이용해 우선순위가 내림차순 순으로 주어지게 할 수 있다.
```



## 투 포인터

특정 조건을 만족하는 연속된 구간을 찾을 때 유용하다.

구간의 시작과 끝을 가리키는 두 포인터를 하나씩 이동시켜가며 구간을 찾게 된다.

```
int start = 0;
int end = arr.length - 1;

int s = 0;
int e = s;

while(s < arr.length)
{
	if(조건 달성)
	{
		if(e - s < end - start)
		{
			start = s;
			end = e;
		}
		
		(기존 s에 해당되는 것을 지운 뒤 조건 체크하도록)
		s++;
		// s++을 하게되면 (조건을 만족했다는 가정하에) 
		범위가 줄어들고 e++를 하게되면 범위가 줄어든다.
	}
	else if(e < arr.length - 1)
	{
		e++;
		(e++에 해당되는 것을 삽입해서 조건 체크하도록)
	}
}
```


## 유니온 파인드

유니온 파인드는 서로소 집합(disjoint set) 자료 구조를 사용하는 알고리즘이다.

서로소 집합은 공통된 원소를 가지고 있지 않은 2개 이상의 집합으로, 유니온 파인드에서는 모든 원소가 자신만 들어 있는 집합에 속한 상태로 시작한다. 이후 원소들이 서로 연결되는 등 정보를 이용하여 집합이 점점 합쳐진다.

즉 서로 연결되어 있는지를 확인할 때 활용가능하다.

```
//원소들의 연결을 Node라고 했을 때, Node가 일렬로 합쳐지지 않게 하는 방법으로 아래와 같이 사용가능하다.

//루트 노드를 구할 때 부모 노드를 루트 노드로 업데이트하는 방법이다.
//루트 노드를 제외한 연결된 모든 노드의 부모노드가 루트노드가 되기 때문에 O(1)만에 같은 집합에 속하는지 알 수 있다.
//따라서 루트노드가 서로 같다면 같은 집합에 속하게 되는 것이다.

private static class Node{
	private Node parent = null;
	
	public boolean isConnected(Node o){
		return root() == o.root();
	}
	
	public void merge(Node o){
		if(isConnected(o)) return;
		o.parent = this;
	}

	private Node root(){
		if(parent == null) return this; // 루트노드 전용
		return parent = parent.root();
	}
}
```

## 크루스칼 알고리즘(+유니온 파인드)

- 최소신장트리
	
	간선에 가중치가 있는 그래프에서 간선의 가중치 합이 최소가 되는 트리

'간선을 가중치 순으로 정렬한 후 순서대로 순회'하면서 연결되지 않은 두 정점을 잇는 간선을 채택해나가면 된다. 이 방식이 크루스칼 알고리즘이다.

두 정점이 연결되었는지 검사하기 위해 유니온 파인드를 활용한다.

-크루스칼 알고리즘 + 유니온파인드의 활용

```
int[][] costs = [[0,1,1], [0,2,2], [1,2,5], [1,3,1], [2,3,8]];
//0과 1이 가중치 1인 간선으로 연결되어 있다는 뜻.

class Edge
{
	public final int u;
	public final int v;
	public final int cost;

	private Edge(int u, int v, int cost)
	{
		this.u = u;
		this.v = v;
		this.cost = cost;
	}
}

Edge[] edges = new Edge(costs);
Arrays.sort(edges, (a,b) -> a.cost - b.cost);
//크루스칼 알고리즘을 이용하기 위해 비용이 작은 간선부터 순회

for(Edge edge : edges)
{
	Node node1 = nodes[edge.u];
	Node node2 = nodes[edge.v];
	
	//유니온파인드(연결되어있지 않다면 하나의 집합으로)
	if(node1.isConnected(node2)) continue;
	node1.merge(node2);
	
	totalCost += edge.cost;
}

System.out.print(totalCost);
//cost가 최소로 모두 연결되었을 때의 totalCost.
```




## dfs (임시)

완전탐색. 스택과 재귀로 구현이 가능한데 보통 재귀를 선호한다.

for문을 통해 전체를 탐색한다.

visit[]로 방문했는지 체크하고

select[]로 선택한 원소들을 저장한다. 이후 다음 원소를 선택하기 위해 재귀를 통해 전이.

최종 index에 도달했을 때 규칙을 통해 적합한지 검사한다.

최종 index에 전이되고 적합한지 검사한 후 visit[]와 selec을 초기화하고 첫 for문의 i++이 되면 2로 시작하는 모든 경우의 수를 돈다.

//1,2,3,4,5,6,7,8이 있으면 1로 시작하는 모든 경우의 수를 돌게 된 것

## bfs

## 그리디 알고리즘